MAP: Generated 2025-11-22 14:10:11
--app/Domains/Users/Http/Controllers/UserVerificationController.php
<?php

namespace App\Domains\Users\Http\Controllers;

use App\Domains\Users\Models\UserVerification;
use App\Http\Controllers\Controller;
use Barryvdh\Debugbar\Facades\Debugbar;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Plank\Mediable\MediaUploader;

class UserVerificationController extends Controller
{
    public function create()
    {
        $existingVerification = UserVerification::where('user_id', Auth::id())->first();

        if ($existingVerification && in_array($existingVerification->status, ['pending', 'approved'])) {
            return redirect()->route('verification.status');
        }

        return view('verification.submit');
    }

    public function store(Request $request, MediaUploader $uploader)
    {
        $request->validate([
            'id_type' => ['required', 'string', 'in:national_id,drivers_license,passport'],
            'id_front' => ['required', 'image', 'max:2048'],
            'id_back' => ['required', 'image', 'max:2048'],
        ]);

        $user = Auth::user();

        // Prevent re-submission if already pending or approved
        $existingVerification = UserVerification::where('user_id', $user->id)->first();
        if ($existingVerification && in_array($existingVerification->status, ['pending', 'approved'])) {
             return redirect()->route('verification.status')->with('error', 'You already have a pending or approved verification request.');
        }

        // Create or update the verification record first
        $verification = UserVerification::updateOrCreate(
            ['user_id' => $user->id],
            [
                'id_type' => $request->id_type,
                'status' => 'pending',
                'rejection_reason' => null,
                'reviewed_at' => null,
                'reviewed_by' => null,
            ]
        );

        // Upload the front ID and attach to the verification record
        if ($request->hasFile('id_front')) {
            $media = $uploader->fromSource($request->file('id_front'))
                ->toDestination('local', $user->id) // Use user ID as directory
                ->upload();
            $verification->attachMedia($media, 'verification-id-front');
        }

        // Upload the back ID and attach to the verification record
        if ($request->hasFile('id_back')) {
            $media = $uploader->fromSource($request->file('id_back'))
                ->toDestination('local', $user->id) // Use user ID as directory
                ->upload();
            $verification->attachMedia($media, 'verification-id-back');
        }

        return redirect()->route('verification.status')->with('success', 'Your verification documents have been submitted successfully.');
    }

    public function status()
    {
        $user = Auth::user();
        $verification = UserVerification::where('user_id', $user->id)->first();
        $idFrontMedia = $verification ? $verification->getMedia('verification-id-front')->first() : null;
        // debugger
        $idBackMedia = $verification ? $verification->getMedia('verification-id-back')->first() : null;

        return view('verification.status', [
            'verification' => $verification,
            'idFrontMedia' => $idFrontMedia,
            'idBackMedia' => $idBackMedia,
        ]);
    }
}
----
--app/Domains/Users/Models/UserVerification.php
<?php

namespace App\Domains\Users\Models;

use Database\Factories\Domains\Users\Models\UserVerificationFactory;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Plank\Mediable\Mediable;

class UserVerification extends Model
{
    use HasFactory, Mediable;

    protected $guarded = [];

    /**
     * Create a new factory instance for the model.
     *
     * @return \Illuminate\Database\Eloquent\Factories\Factory
     */
    protected static function newFactory()
    {
        return UserVerificationFactory::new();
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function reviewer(): BelongsTo
    {
        return $this->belongsTo(User::class, 'reviewed_by');
    }
}
----
--app/Http/Controllers/MediaServeController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Crypt;
use Plank\Mediable\Media;
use Symfony\Component\HttpFoundation\StreamedResponse;

class MediaServeController extends Controller
{
    /**
     * Handle the incoming request.
     */
    public function __invoke(Request $request, string $encryptedPath): StreamedResponse
    {
        try {
            $path = Crypt::decryptString($encryptedPath);
        } catch (\Illuminate\Contracts\Encryption\DecryptException $e) {
            abort(404);
        }

        $media = Media::where('disk', 'local')->where('directory', dirname($path))->where('filename', basename($path))->firstOrFail();

        // Ensure the user is authorized to view this media
        // For now, we'll assume if it's a verification document, only the owner or admin can view it.
        // This needs to be expanded with proper authorization logic (e.g., policies).
        if ($media->getDisk() === 'local' && $media->getDiskPath() === $path) {
            // Example: Check if the authenticated user is the owner of the media's associated model
            // Or if the user has an 'admin' role.
            // For now, we'll just serve it if it's a local file and the path matches.
            // TODO: Implement proper authorization here.
        } else {
            abort(403, 'Unauthorized to access this media.');
        }

        return response()->streamDownload(
            function () use ($media) {
                $stream = $media->stream();
                while ($bytes = $stream->read(1024)) {
                    echo $bytes;
                }
            },
            $media->basename,
            [
                'Content-Type' => $media->mime_type,
                'Content-Length' => $media->size,
                'Content-Disposition' => 'inline; filename="' . $media->basename . '"', // Display in browser
            ]
        );
    }
}
----
--config/media-privacy.php
<?php

use App\Domains\Users\Models\UserVerification;
use App\Domains\Listings\Models\OpenOffer;

return [
    /*
    |--------------------------------------------------------------------------
    | Media Privacy Settings
    |--------------------------------------------------------------------------
    |
    | This array maps models to their default media privacy.
    | Supported values: 'public', 'private'.
    |
    | - 'public': Media can be viewed by anyone. No authorization checks.
    | - 'private': Media can only be viewed by authorized users.
    |              This requires a policy to be defined for the Media model.
    |
    */

    'default' => 'private',

    'models' => [
        UserVerification::class => 'private',
        OpenOffer::class => 'public',
        // Example of a public model
        // \App\Domains\Listings\Models\Service::class => 'public',
    ],
];
----
--config/mediable.php
<?php

return [
    /*
     * The database connection name to use
     *
     * Set to `null` in order to use the default database connection
     */
    'connection_name' => null,

    /*
     * FQCN of the model to use for media
     *
     * Should extend `Plank\Mediable\Media`
     */
    'model' => Plank\Mediable\Media::class,

    /*
     * Name to be used for mediables joining table
     */
    'mediables_table' => 'mediables',

    /*
     * Filesystem disk to use if none is specified
     */
    'default_disk' => 'public',

    /*
     * Filesystems that can be used for media storage
     *
     * Uploader will throw an exception if a disk not in this list is selected
     */
    'allowed_disks' => [
        'public',
        'local',
    ],

    /*
     * The maximum file size in bytes for a single uploaded file
     */
    'max_size' => 1024 * 1024 * 10,

    /*
     * What to do if a duplicate file is uploaded.
     *
     * Options include:
     *
     * * `'increment'`: the new file's name is given an incrementing suffix
     * * `'replace'` : the old file and media model is deleted
     * * `'error'`: an Exception is thrown
     */
    'on_duplicate' => Plank\Mediable\MediaUploader::ON_DUPLICATE_INCREMENT,

    /*
     * Reject files unless both their mime and extension are recognized and both match a single aggregate type
     */
    'strict_type_checking' => false,

    /*
     * Reject files whose mime type or extension is not recognized
     * if true, files will be given a type of `'other'`
     */
    'allow_unrecognized_types' => false,

    /**
     * Prefer the client-provided MIME type over the one inferred from the file contents, if provided
     * May be slightly faster to compute, but is not guaranteed to be accurate if the source is untrusted
     */
    'prefer_client_mime_type' => false,

    /*
     * Only allow files with specific MIME type(s) to be uploaded
     */
    'allowed_mime_types' => [],

    /*
     * Only allow files with specific file extension(s) to be uploaded
     */
    'allowed_extensions' => [],

    /*
     * Only allow files matching specific aggregate type(s) to be uploaded
     */
    'allowed_aggregate_types' => [],

    /*
     * List of aggregate types recognized by the application
     *
     * Each type should list the MIME types and extensions
     * that should be recognized for the type
     */
    'aggregate_types' => [
        Plank\Mediable\Media::TYPE_IMAGE => [
            'mime_types' => [
                'image/jpeg',
                'image/png',
                'image/gif',
                'image/heic',
            ],
            'extensions' => [
                'jpg',
                'jpeg',
                'png',
                'gif',
                'heic',
            ]
        ],
        Plank\Mediable\Media::TYPE_IMAGE_VECTOR => [
            'mime_types' => [
                'image/svg+xml',
            ],
            'extensions' => [
                'svg',
            ]
        ],
        Plank\Mediable\Media::TYPE_PDF => [
            'mime_types' => [
                'application/pdf',
            ],
            'extensions' => [
                'pdf',
            ]
        ],
        Plank\Mediable\Media::TYPE_AUDIO => [
            'mime_types' => [
                'audio/aac',
                'audio/ogg',
                'audio/mpeg',
                'audio/mp3',
                'audio/mpeg',
                'audio/wav'
            ],
            'extensions' => [
                'aac',
                'ogg',
                'oga',
                'mp3',
                'wav',
            ]
        ],
        Plank\Mediable\Media::TYPE_VIDEO => [
            'mime_types' => [
                'video/mp4',
                'video/mpeg',
                'video/ogg',
                'video/webm'
            ],
            'extensions' => [
                'mp4',
                'm4v',
                'mov',
                'ogv',
                'webm'
            ]
        ],
        Plank\Mediable\Media::TYPE_ARCHIVE => [
            'mime_types' => [
                'application/zip',
                'application/x-compressed-zip',
                'multipart/x-zip',
            ],
            'extensions' => [
                'zip',
            ]
        ],
        Plank\Mediable\Media::TYPE_DOCUMENT => [
            'mime_types' => [
                'text/plain',
                'application/plain',
                'text/xml',
                'text/json',
                'application/json',
                'application/msword',
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
            ],
            'extensions' => [
                'doc',
                'docx',
                'txt',
                'text',
                'xml',
                'json',
            ]
        ],
        Plank\Mediable\Media::TYPE_SPREADSHEET => [
            'mime_types' => [
                'application/vnd.ms-excel',
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            ],
            'extensions' => [
                'xls',
                'xlsx',
            ]
        ],
        Plank\Mediable\Media::TYPE_PRESENTATION => [
            'mime_types' =>
                [
                    'application/vnd.ms-powerpoint',
                    'application/vnd.openxmlformats-officedocument.presentationml.presentation',
                    'application/vnd.openxmlformats-officedocument.presentationml.slideshow'
                ],
            'extensions' =>
                [
                    'ppt',
                    'pptx',
                    'ppsx',
                ]
        ],
    ],

    /*
     * List of adapters to use for various source inputs
     *
     * Adapters can map either to a class or a pattern (regex)
     */
    'source_adapters' => [
        'class' => [
            Symfony\Component\HttpFoundation\File\UploadedFile::class => Plank\Mediable\SourceAdapters\UploadedFileAdapter::class,
            Symfony\Component\HttpFoundation\File\File::class => Plank\Mediable\SourceAdapters\FileAdapter::class,
            Psr\Http\Message\StreamInterface::class => Plank\Mediable\SourceAdapters\StreamAdapter::class,
        ],
        'pattern' => [
            '^https?://' => Plank\Mediable\SourceAdapters\RemoteUrlAdapter::class,
            '^/' => Plank\Mediable\SourceAdapters\LocalPathAdapter::class,
            '^[a-zA-Z]:\\\\' => Plank\Mediable\SourceAdapters\LocalPathAdapter::class,
            '^data:/?/?[^,]*,' => Plank\Mediable\SourceAdapters\DataUrlAdapter::class,
        ],
    ],

    /*
     * List of URL Generators to use for handling various filesystem drivers
     *
     */
    'url_generators' => [
        'local' => Plank\Mediable\UrlGenerators\LocalUrlGenerator::class,
        's3' => Plank\Mediable\UrlGenerators\S3UrlGenerator::class,
    ],

    /**
     * Should mediable instances automatically reload their media relationships after modification are made to a tag.
     *
     * If true, will automatically reload media the next time `getMedia()`, `getMediaMatchAll()` or `getAllMediaByTag()` are called.
     */
    'rehydrate_media' => true,

    /**
     * Detach associated media when mediable model is soft deleted.
     */
    'detach_on_soft_delete' => false,

    /**
     * Prevents loading migrations from the package.
     *
     * Use this if you are renaming the published migrations and want to prevent them from being loaded twice.
     */
    'ignore_migrations' => false,

    /**
     * Configuration for image optimization
     */
    'image_optimization' => [
        /**
         * Whether to apply image optimization after performing image manipulations by default
         */
        'enabled' => true,
        /**
         * array of optimizers to use, which should implement \Spatie\ImageOptimizer\Optimizer
         * Each can be passed an array of command line arguments to be passed to the optimizer
         */
        'optimizers' => [
            \Spatie\ImageOptimizer\Optimizers\Jpegoptim::class => [
                '--max=85',
                '--strip-all',
                '--all-progressive',
            ],
            \Spatie\ImageOptimizer\Optimizers\Pngquant::class => [
                '--quality=85',
                '--force',
                '--skip-if-larger',
            ],
            \Spatie\ImageOptimizer\Optimizers\Optipng::class => [
                '-i0',
                '-o2',
                '-quiet',
            ],
            \Spatie\ImageOptimizer\Optimizers\Gifsicle::class => [
                '-b',
                '-O3',
            ],
            \Spatie\ImageOptimizer\Optimizers\Cwebp::class => [
                '-q 80',
                '-m 6',
                '-pass 10',
                '-mt',
            ],
            \Spatie\ImageOptimizer\Optimizers\Avifenc::class => [
                '-a cq-level=23',
                '-j all',
                '--min 0',
                '--max 63',
                '--minalpha 0',
                '--maxalpha 63',
                '-a end-usage=q',
                '-a tune=ssim',
            ],
        ],
    ]
];
----
--resources/views/admin/verifications/show.blade.php
<x-app-layout>
    <x-slot name="header">
        <h2 class="font-semibold text-xl text-gray-800 leading-tight">
            Review Verification for {{ $verification->user->firstname }} {{ $verification->user->lastname }}
        </h2>
    </x-slot>

    <div class="py-12">
        <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
            <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg">
                <div class="p-6 bg-white border-b border-gray-200">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h3 class="text-lg font-bold">User Details</h3>
                            <p><strong>Name:</strong> {{ $verification->user->firstname }} {{ $verification->user->lastname }}</p>
                            <p><strong>Email:</strong> {{ $verification->user->email }}</p>
                            <p><strong>ID Type:</strong> {{ $verification->id_type }}</p>
                            <p><strong>Submitted At:</strong> {{ $verification->created_at->format('Y-m-d H:i') }}</p>
                        </div>
                        <div>
                            <h3 class="text-lg font-bold">Actions</h3>
                            <div class="mt-4 flex space-x-4">
                                <!-- Approve Form -->
                                <form method="POST" action="{{ route('admin.verifications.approve', $verification) }}">
                                    @csrf
                                    <x-primary-button>Approve</x-primary-button>
                                </form>

                                <!-- Reject Form -->
                                <form method="POST" action="{{ route('admin.verifications.reject', $verification) }}" x-data="{ showRejectReason: false }">
                                    @csrf
                                    <x-danger-button @click.prevent="showRejectReason = !showRejectReason">Reject</x-danger-button>

                                    <div x-show="showRejectReason" class="mt-4">
                                        <x-input-label for="rejection_reason" :value="__('Reason for Rejection')" />
                                        <textarea id="rejection_reason" name="rejection_reason" rows="3" class="block mt-1 w-full rounded-md shadow-sm border-gray-300 focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50" required></textarea>
                                        @error('rejection_reason')
                                            <p class="text-sm text-red-600 mt-1">{{ $message }}</p>
                                        @enderror
                                        <x-primary-button class="mt-2">Confirm Rejection</x-primary-button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    </div>

                    <div class="mt-8">
                        <h3 class="text-lg font-bold">Submitted Documents</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-4">
                            <div>
                                <h4 class="font-semibold">Front of ID</h4>
                                @if ($idFrontMedia)
                                    <img src="{{ route('media.serve', ['payload' => \Illuminate\Support\Facades\Crypt::encryptString(json_encode(['media_id' => $idFrontMedia->id]))]) }}" alt="Front of ID" class="mt-2 border rounded-md">
                                @else
                                    <p>No image uploaded.</p>
                                @endif
                            </div>
                            <div>
                                <h4 class="font-semibold">Back of ID</h4>
                                @if ($idBackMedia)
                                    <img src="{{ route('media.serve', ['payload' => \Illuminate\Support\Facades\Crypt::encryptString(json_encode(['media_id' => $idBackMedia->id]))]) }}" alt="Back of ID" class="mt-2 border rounded-md">
                                @else
                                    <p>No image uploaded.</p>
                                @endif
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </div>
</x-app-layout>
----
--resources/views/verification/submit.blade.php
<x-app-layout>
    <x-slot name="header">
        <h2 class="font-semibold text-xl text-gray-800 leading-tight">
            {{ __('Verify Your Identity') }}
        </h2>
    </x-slot>

    <div class="py-12">
        <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
            <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg">
                <div class="p-6 bg-white border-b border-gray-200">
                    <form method="POST" action="{{ route('verification.store') }}" enctype="multipart/form-data">
                        @csrf

                        <!-- ID Type -->
                        <div>
                            <x-input-label for="id_type" :value="__('ID Type')" />
                            <select id="id_type" name="id_type" class="block mt-1 w-full rounded-md shadow-sm border-gray-300 focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                                <option value="national_id">{{ __('National ID') }}</option>
                                <option value="drivers_license">{{ __("Driver's License") }}</option>
                                <option value="passport">{{ __('Passport') }}</option>
                            </select>
                        </div>

                        <!-- ID Front -->
                        <div class="mt-4">
                            <x-input-label for="id_front" :value="__('Front of ID')" />
                            <x-text-input id="id_front" class="block mt-1 w-full" type="file" name="id_front" required />
                        </div>

                        <!-- ID Back -->
                        <div class="mt-4">
                            <x-input-label for="id_back" :value="__('Back of ID')" />
                            <x-text-input id="id_back" class="block mt-1 w-full" type="file" name="id_back" required />
                        </div>

                        <div class="flex items-center justify-end mt-4">
                            <x-primary-button>
                                {{ __('Submit for Verification') }}
                            </x-primary-button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</x-app-layout>
----
--routes/web.php
<?php
use Illuminate\Support\Facades\Route;
use App\Domains\Listings\Http\Controllers\ServiceController;
use App\Domains\Users\Http\Controllers\ProfileController;
use App\Domains\Users\Http\Controllers\UserVerificationController;
use App\Domains\Users\Http\Controllers\Admin\UserVerificationController as AdminUserVerificationController;
use App\Domains\Listings\Http\Controllers\CategoryController;
use App\Domains\Common\Http\Controllers\MediaServeController;
use App\Domains\Listings\Http\Controllers\ListingController;
use App\Domains\Listings\Http\Controllers\WorkCatalogController;
use App\Domains\Listings\Http\Controllers\WorkflowTemplateController;
use App\Domains\Listings\Http\Controllers\WorkTemplateController;
use App\Domains\Listings\Http\Controllers\OpenOfferController;
use App\Domains\Listings\Http\Controllers\OpenOfferBidController; // Added

// Authentication routes
require __DIR__.'/auth.php';

// Home and static pages
    Route::get('/', function () {
        return view('home');
    })->name('home');

    Route::get('browse', [ListingController::class, 'index'])->name('browse');

    Route::get('create', function () {
        return view('create');
    })->name('create');

    Route::get('about', function () {
        return view('about');
    })->name('about');

    Route::get('faq', function () {
        return view('faq');
    })->name('faq');

// Public-facing service page
Route::get('/services/{service}', [ServiceController::class, 'show'])->name('services.show');

// Public-facing open offer page
Route::get('/openoffers/{openoffer}', [OpenOfferController::class, 'show'])->name('openoffers.show');

// Creator space
Route::middleware(['auth'])->prefix('creator')->name('creator.')->group(function () {
    Route::get('/', function () {
        return view('dashboard');
    })->name('dashboard');

    // Service Management
    Route::resource('services', ServiceController::class);
    Route::get('services/{service}/manage', [ServiceController::class, 'manage'])->name('services.manage');

    // Category Management
    Route::resource('categories', CategoryController::class);

    // Open Offer Management
    Route::resource('openoffers', OpenOfferController::class)->except(['show']);
    Route::post('openoffers/{openoffer}/close', [OpenOfferController::class, 'close'])->name('openoffers.close');

    // Bidding Management
    Route::prefix('openoffers/{openoffer}')->name('openoffers.')->group(function () {
        Route::resource('bids', OpenOfferBidController::class);
        Route::post('bids/{bid}/accept', [OpenOfferBidController::class, 'accept'])->name('bids.accept');
        Route::post('bids/{bid}/reject', [OpenOfferBidController::class, 'reject'])->name('bids.reject');
    });

    // Workflow Management
    Route::get('workflows', [WorkflowTemplateController::class, 'index'])->name('workflows.index');
    Route::get('workflows/create', [WorkflowTemplateController::class, 'create'])->name('workflows.create');
    Route::get('workflows/{workflow}/edit', [WorkflowTemplateController::class, 'edit'])->name('workflows.edit');
    Route::patch('workflows/{workflow}', [WorkflowTemplateController::class, 'update'])->name('workflows.update');
    Route::delete('workflows/{workflow}', [WorkflowTemplateController::class, 'destroy'])->name('workflows.destroy');
    Route::post('workflows/{workflow}/duplicate', [WorkflowTemplateController::class, 'duplicate'])->name('workflows.duplicate');
});

// User Verification
Route::middleware(['auth'])->prefix('verification')->name('verification.')->group(function () {
    Route::get('/submit', [UserVerificationController::class, 'create'])->name('create');
    Route::post('/', [UserVerificationController::class, 'store'])->name('store');
    Route::get('/status', [UserVerificationController::class, 'status'])->name('status');
});

// Profile editor
   Route::middleware(['auth'])->prefix('profile')->group(function () {
        Route::get('/', [ProfileController::class, 'edit'])
            ->name('profile.edit');

        Route::patch('/', [ProfileController::class, 'update'])
            ->name('profile.update');

        Route::delete('/', [ProfileController::class, 'destroy'])
            ->name('profile.destroy');
});

// Admin Routes
Route::middleware(['auth'])->prefix('admin')->name('admin.')->group(function () {
    Route::get('/verifications', [AdminUserVerificationController::class, 'index'])->name('verifications.index');
    Route::get('/verifications/{verification}', [AdminUserVerificationController::class, 'show'])->name('verifications.show');
    Route::post('/verifications/{verification}/approve', [AdminUserVerificationController::class, 'approve'])->name('verifications.approve');
    Route::post('/verifications/{verification}/reject', [AdminUserVerificationController::class, 'reject'])->name('verifications.reject');
});

Route::get('/media/serve/{payload}', [MediaServeController::class, '__invoke'])
    ->middleware('auth')
    ->name('media.serve');




----
--SUMMARY
Text:8 Binary:0 Skipped:785
